#!/usr/bin/env perl
# 02/07/2013 - TRCM - cleanup (v0.1)
#                   - overengineer++ (v0.5)
# 22/08/2013 - TRCM - grok BladeLogic port 4750 (v0.999)
# 03/09/2013 - TRCM - fix errors from warnings and strict
#                   - don't write to socket unless we can
#                   - portable chomp for dos/win style responses
#                   - add debug mode to view response data (v1.1)
# 05/09/2013 - TRCM - jiggle output, and early exit on socket data parsing (v2)
#                   - colour bitches! (v2.5)
# 18/09/2013 - TRCM - Prelim IPv6 support, not so portable. draft HTTP parsing (v2.6.5)
# 19/09/2013 - TRCM - Faster HTTP parsing, early exit on empty socket read (v2.7.1)
# 25/09/2013 - TRCM - rejig layout
my $version = "2.7.2";

#use IO::Socket::INET6;
use IO::Socket::INET;
use IO::Select;

sub trim($);
sub wtf;
sub hexprint($);
sub hex2ascii($);

my $remote_host = ( defined $ARGV[0] ) ? trim($ARGV[0]) : "";
wtf() if $remote_host =~ /^(-h:--help|)$/;
my $remote_port = ( defined $ARGV[1] ) ? $ARGV[1] : 22; # default to port 22
my $timeout = ( defined $ARGV[2] ) ? $ARGV[2] : 3;      # default to 3 seconds
my $debug = ( defined $ARGV[3] );                       # debug if debug
my $socket_received;
my $socket_parsed;
my $colour_success = 32; # 31=red,32=green,33=yellow
my $colour_fail = 31;
my $socket_read_length = 128; # bytes
my @fragments = ( 0 ); # Read just once from the socket

#my $socket = IO::Socket::INET6->new(
my $socket = IO::Socket::INET->new(
   PeerAddr => $remote_host,
   PeerPort => $remote_port,
   Proto    => "tcp",
   Type     => SOCK_STREAM,
   Timeout  => $timeout
) or do {
   # We couldn't open a socket, let the user have the reason why from IO::Socket
   if (-t STDOUT) {
      printf("%s, \e[%dmFailure\e[m, TCP %d, %d secs, %s\n",$remote_host,$colour_fail,$remote_port,$timeout,$@);
   } else {
      printf("%s,Failure,TCP %d,%d secs,%s\n",$remote_host,$remote_port,$timeout,$@);
   }
   exit 1;
};

for ($remote_port) {
   /4750|bl/  && do {
                      # If we're checking the RSCD(4750/tcp) service, send some magic first
                      # The clienthello string contents were experimentally found
                      my $socket_send_rscdinit = "TLS";
                      my $socket_send_rscdclienthello = pack( 'H*', '16030100490100004503015215ef8253b424768b3a19e6f8def4ebf0157db11d475b97c4d40b3e0af6c26e00001800390038003500160013000a00330032002f0007000500ff0100000400230000' );
                      if ( () - IO::Select->new($socket)->can_write($timeout) ) {
                         $socket->send($socket_send_rscdinit);
                         $socket->send($socket_send_rscdclienthello);
                         $socket_read_length = 256;
                      }
                   };
   /80/    && do {
                      # If we're checking the HTTP(80/tcp) service, fire a GET
                      my $socket_send_httpsinit = "GET / HTTP/1.1\r\nhost: $remote_host\r\n\r\n";
                      if ( () - IO::Select->new($socket)->can_write($timeout) ) {
                         $socket->send($socket_send_httpsinit);
                         $socket_read_length = 512;
                         @fragments = ( 0,1,2,3,4,5,6,7 ); # Read several times from the socket, as response often fragmented
                      }
                   };
}

for my $frag (0 .. $#fragments) {
   if ( defined() - IO::Select->new($socket)->can_read($timeout) ) {
      $socket->recv($frag,$socket_read_length);
      # Build up the response from however many fragments we read from the socket
      $socket_received = $socket_received . $frag;
   }
   # If we read nothing from the socket on the last iteration, stop reading
   last unless $frag;
}
close($socket);

for ($socket_received) {
   /^$/                        && do {$socket_parsed = "Nothing"; last;};
   /^SSH-2.0-IPSSH-1.10.0/     && do {$socket_parsed = "looks like HPLO-100"; last;};
   /^SSH-2.0-mpSSH_0.0.1/      && do {$socket_parsed = "looks like HPILOv1"; last;};
   /^SSH-2.0-mpSSH_0.1.0/      && do {$socket_parsed = "looks like HPILOv2"; last;};
   /^SSH-2.0-mpSSH_0.1.1/      && do {$socket_parsed = "looks like HPILOv2"; last;};
   /^SSH-2.0-RomSShell_4.62/   && do {$socket_parsed = "looks like HPILOv3"; last;};
   /^SSH-2.0-OpenSSH_OA/       && do {$socket_parsed = "looks like HP-OA"; last;};
   # These are not specific enough.
   #/^SSH-2.0-OpenSSH_5.0/      && do {$socket_parsed = "looks like Linux(XSCF)"; last;};
   #/^SSH-2.0-OpenSSH_3.6.1p2/  && do {$socket_parsed = "looks like Linux(XSCF)"; last;};
   /^SSH-2.0-Sun_SSH/          && do {$socket_parsed = "looks like Solaris"; last;};
   # These are good for HTTP parsing
   /Server: /                  && do {m/Server: (.+)/; $socket_parsed=$1; last;};
   /title/                     && do {m/title>[\r\n]*(.+?)<\/title/sg; $socket_parsed=$1; last;};
   # BladeLogic responses have this
   /rscd/                      && do {$socket_parsed = "looks like BladeLogic RSCD"; last;};
   # Failed to match, so set the output to be the raw response trimmed to just the first line
   @socket_parsed=split /\n/,$socket_received;
   $socket_parsed=$socket_parsed[0];
}
# portable chomp
$socket_parsed =~ s/\015?\012?$//;
if ($debug) {
   binmode(STDOUT, ":utf8");
   printf("%s, Success, TCP %d, %d secs, %s, %s\n",$remote_host,$remote_port,$timeout,$socket_parsed,hex2ascii(hexprint($socket_received)));
} else {
   if (-t STDOUT) {
      printf("%s, \e[%dmSuccess\e[m, TCP %d, %d secs, %s\n",$remote_host,$colour_success,$remote_port,$timeout,$socket_parsed);
   } else {
      printf("%s,Success,TCP %d,%d secs,%s\n",$remote_host,$remote_port,$timeout,$socket_parsed);
   }
}
exit 0;

sub trim($) {
   my $string = shift;
   $string =~ s/^\s+//;
   $string =~ s/\s+$//;
   return $string;
}

sub hexprint($) {
    my ($string)=@_;
    my $hex="";
    my $offset=0;
    my @bytes=unpack "C*",$string;
    foreach my $byte (@bytes) {
        $hex=$hex . sprintf "%02x",$byte;
        $offset++;
    };
    return $hex;
}

sub hex2ascii($) {
   my ($hex)=@_;
   if ($hex =~ /:/) {
      $hex =~ s/[: ]//g;
   }
   $string = join("",pack("H*",$hex) =~ m/(.)/g);
   # Print the unprintable as unicode
   $string =~ tr[\0-\x1F\x7F] [\x{2400}-\x{241F}\x{2421}];
   return $string;
}

sub wtf {
   die("Version:  $version\nUsage:  pport hostname [tcp_port] [timeout_secs] [debug]\n");
}
